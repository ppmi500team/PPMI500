---
title: "PPMI500 data curation effort"
author:
  - Brian B. Avants^1,2^
  - Lino Becerra^1^
  - Leon Fonville^2,†^
  - Olivia Hampton^1,†^
  - Alexandra Reardon^1,†^
  - Andrew Stenger^1,†^
  - Xue Wang^1,†^
  - Roger Gunn
affiliation:
  - "1: Invicro, Boston, MA, FIMXE, USA"
  - "2: Invicro, FIMXE, UK"
corresponding_author: "Brian B. Avants (stnava@gmail.com)"
contributed_equally: "† these authors contributed equally to this work"
output: html_document
classoption: table
urlcolor: blue
link-citations: true
---



```{r ppmimerge0, echo=FALSE,eval=TRUE}
library(ztable)
options(ztable.zebra.color="platinum")
options(ztable.colnames.bold=TRUE)
options(ztable.include.rownames=FALSE)
library(moonBook)
library(plyr)
library(subtyper)
library(forcats)
library(lmerTest)
library(lme4)
library(ggplot2)
library(ggpubr)
library(gridExtra)
library(mclust)
library(MASS)
library(dCUR)
library(mlr3learners)
library(ANTsR)
library(mlr3verse)
library(rsq)
library(ggplot2)
library(modelsummary)
```

```{r ppmimerge1, echo=FALSE,eval=TRUE}


add_vectors_with_na <- function(a, b) {
  # Check if the vectors are of the same length
  if(length(a) != length(b)) {
    stop("The vectors must be of the same length.")
  }
  
  # Initialize the result vector
  result <- vector("numeric", length(a))
  
  # Loop through each element of the vectors
  for(i in seq_along(a)) {
    # If both elements are NA, the result is NA
    if(is.na(a[i]) && is.na(b[i])) {
      result[i] <- NA
    # If one of the elements is NA, use the other element
    } else if(is.na(a[i])) {
      result[i] <- b[i]
    } else if(is.na(b[i])) {
      result[i] <- a[i]
    # If neither element is NA, sum the elements
    } else {
      result[i] <- a[i] + b[i]
    }
  }
  
  return(result)
}

#' Calculate Success and Failure Rates by Modality
#'
#' This function calculates success and failure rates for a given column in a data frame
#' based on specified conditions for success and failure. The calculations are grouped by
#' the 'modality' column.
#'
#' @param data A data frame containing the data to be analyzed.
#' @param column_name The name of the column for which to calculate success and failure rates.
#' @param success_condition A string representing the condition that defines a success.
#' @param failure_condition A string representing the condition that defines a failure.
#'
#' @return A data frame with success and failure rates calculated for each modality.
#' @examples
#' calculate_success_failure_rates(data, "NM_QC_Ratings_Failures", "== 0", "> 0")
#' calculate_success_failure_rates(data, "NM_QC_Ratings_Z", "== 1", "== 0")
#'
#' @export
calculate_success_failure_rates <- function(data, column_name, success_condition, failure_condition) {
  # Check if 'data' is a data frame
  if (!is.data.frame(data)) {
    stop("The 'data' argument must be a data frame.")
  }
  
  # Check if 'column_name' exists in 'data'
  if (!column_name %in% names(data)) {
    stop(paste("Column", column_name, "not found in the data frame."))
  }
  data=data[ !is.na(data[,column_name]), ]
  # Ensure 'success_condition' and 'failure_condition' are properly formatted strings
  if (!is.character(success_condition) || !is.character(failure_condition)) {
    stop("Both 'success_condition' and 'failure_condition' must be character strings.")
  }
  
  # Dynamically construct the expressions for success and failure conditions
  success_expr <- rlang::parse_expr(paste0(column_name, success_condition))
  failure_expr <- rlang::parse_expr(paste0(column_name, failure_condition))
  
  # Calculate success and failure rates
  success_failure_data <- data %>%
    mutate(Success = !!success_expr, 
           Failure = !!failure_expr) %>%
    group_by(modality) %>%
    summarise(Total = n(),
              Successes = sum(Success, na.rm = TRUE),
              Failures = sum(Failure, na.rm = TRUE)) %>%
    mutate(Percent_Success = Successes / Total * 100,
           Percent_Failure = Failures / Total * 100)
  
  success_failure_data$failcat=column_name
  return(success_failure_data)
}

```


```{r normex, echo=FALSE,eval=FALSE}
slfasym="DTI_mean_md.superior_longitudinal_fasciculus.Asym.jhu_icbm_labels_1mm" 
rsfvar="rsfMRI_fcnxpro122_SomMotA_2_ContC"
nmvar='NM2DMT_NM_avg_substantianigra'
nmvar2='NM2DMT_NM_avg_refregion'
selid='140469_20220615'
selid='101279_20210620'

ppmi500=antspymm_predictors(ppmi500,TRUE)
slit = subtyper::fs(ppmi500$T1Hier_resnetGrade > 1.05 )#  & ppmi500[,nmvar] < 1050 )
ppmi500sel=ppmi500[ slit, ]
ppmi500sel[,nmvar]=ppmi500sel[,nmvar]-ppmi500sel[,nmvar2]
# residuals(lm(NM2DMT_NM_avg_substantianigra~NM2DMT_NM_avg_refregion+NM2DMT_NM_count+NM2DMT_NM_evr+NM2DMT_NM_avg_signaltonoise,data=ppmi500sel))
wrow=303 # low connex
selid='101279_20210620' # maybe pd+
selid='140469_20220615' # no 
selid='188666_20230131' # yes pd-
# selid='140452_20220503' # yes pd+
multivars=c("commonAge", "DXSubAsyn", 
    "T1Hier_vol_mtg_sn_snc_LRAVGcit168", 
    "T1Hier_vol_bn_gp_gpe_LRAVGcit168", 
#    "T2Flair_flair_wmh_prior", 
    "T1Hier_vol_bn_str_pu_LRAVGcit168", slfasym, rsfvar, 'updrs_totscore' ) 
haveall=rep(TRUE,nrow(ppmi500))
for ( x in multivars ) { 
  haveall=haveall & !is.na( ppmi500[,x])
}
ppmi500$haveall=haveall
#####################################
wrow = which(ppmi500sel$id == selid )
# for ( wrow in which( ppmi500sel[,'rsfMRI_fcnxpro122_SomMotA_2_ContC'] < -0.2)  ) {
xx=normativeSummary( ppmi500sel, wrow, mulitvars)
# Sys.sleep(3)
# }


xx=normativeSummary( ppmi500, 487, c("commonAge","commonSex", "T2Flair_flair_wmh_prior", "DXSubAsyn", 
  "T1Hier_vol_mtg_sn_snc_LRAVGdeep_cit168", 
  "T1Hier_vol_bn_gp_gpe_LRAVGdeep_cit168", 
  "T1Hier_vol_bn_str_pu_LRAVGcit168", 
  "DTI_mean_fa.fornix_.cres..stria_terminalis_.can_not_be_resolved_with_current_resolution..LRAVG.jhu_icbm_labels_1mm"), 
  zoom=35 )


# Example usage
# rsyncFolder("/path/to/source/folder", "/path/to/destination/folder")
```


```{r ppmiread, echo=FALSE,eval=FALSE}
if ( ! exists("clin2b") ) {
  rdir=path.expand('~/code/multidisorder/data/')
  rdir=path.expand('~/Downloads/ppmi_pym_data/')
  if ( ! exists("pymf") ) {
    pymfns = data.frame( 
      fns=c( 
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSV_v1.2.7.csv'),
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSVSRFIRST_v1.2.7.csv'),
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSVSRNext_v1.2.7.csv')  ),
      rez=c("OR","SRF","SRP") )
    print(paste("ANTsPyMM Pipeline : ", myrez ) )
    pym = read.csv(  pymfns$fn[pymfns$rez == myrez ] )
    pymf = pym[ , !(colnames(pym) %in% getNamesFromDataframe("u_hier_id", pym))] # junk
    pymf = filterNAcolumns( pymf, 20 ) # remove columns with > 20% missing
    pymf[ is.na(pymf$mrimfg), 'mrimfg' ]='Unk'
    pymf[ is.na(pymf$mrimodel), 'mrimodel' ]='Unk'
    rm(pym)
    }
  if ( ! exists("adni") ) 
    adni = read.csv( path.expand("~/code/multidisorder/data/adni_gwas/ADNIMERGE_10Feb2024_antspymm_v1.2.7.csv") )
  studynames=c("ADNI", "NIFD4RTNI", "PPMI","UKBB","A4")
  dxnames= c("DX_bl", "DX", "DXSub", "DX", "DX" )
  sexnames=c("PTGENDER","SEX","SEX","sex_f31_0_0","PTGENDER")
  agenames=c("AGE","Age_BL","age_BL","subjectAge_BL","PTAGE")
  edunames=c("PTEDUCAT","EDUCATION","EDUCYRS","age_completed_full_time_education_f845_0_0","PTEDUCAT")
  sidnames=c("PTID","LONI_ID","PATNO","eid","sid")
  viznames=c("Years.bl","deltaTime","yearsbl","Years.bl","Years.bl")
  adni$commonSex = adni$PTGENDER
  adni$commonEdu = adni$PTEDUCAT
  adni$commonID = adni$subjectID = adni$PTID
  adni$age_BL = adni$age = adni$AGE
  adni$yearsbl = adni$Years_bl
  adni$joinedDX = adni$DX_bl
  adni$joinedDX[ grep("MCI",adni$joinedDX)]="MCI"
  adni$joinedDX[ adni$joinedDX == ""]=NA
  adni$studyName='ADNI'
  adniasynfn = path.expand( "~/code/multidisorder/data/adni_gwas/AMPRION_ASYN_SAA_13Nov2023.csv")
  adniasyn = read.csv( adniasynfn )
  names( adniasyn )[ names(adniasyn) == 'Result' ]='AsynStatus'
  adniasyn[ subtyper::fs(adniasyn$AsynStatus %in% c('Detected-1','Detected-2')) , 'AsynStatus'] = 'Positive'
  adniasyn[ subtyper::fs(adniasyn$AsynStatus %in% c('Not_Detected','Indeterminate')), 'AsynStatus' ] = 'Negative'
  # map 
  adni$AsynStatus=NA
  uids = unique( adniasyn$RID[!is.na(adniasyn$AsynStatus)])
  for ( k in 1:nrow(adniasyn) ) {
        losel = subtyper::fs( adni$RID == adniasyn$RID[k] )
        if ( sum(losel) > 0 ) {        
            adni$AsynStatus[ losel ] = adniasyn$AsynStatus[k]
        }
    }
  demog=read.csv(paste0(rdir,"Demographics_06Feb2024.csv"))
  curfn=paste0(rdir,'PPMI_Curated_Data_Cut_Public_20230612_rev.csv')
  saafn = paste0(rdir,'PPMI_CSFSAA_09Oct2023/PPMI_CSFSAA_09Oct2023.csv')
  if ( ! file.exists( saafn ) ) {
    saafn = paste0(rdir,'PPMI_CSFSAA_09Oct2023.csv')
    }
  saa=read.csv( saafn )
  ppmidemog0=read.csv( curfn )
  clin2b = merge_ppmi_imaging_clinical_demographic_data(
    demog, ppmidemog0, pymf, pymversion=myrez, saa )
  # add tracker
  tracker = read.csv(paste0(rdir,"ppmi_2_0_internal_scan_tracking_report_v12-2024-02-08.csv"))

  tracker = tracker[ tracker$Modality == "MR", ]
  tracker$EVENT_ID=tracker$Visit
  tracker$EVENT_ID[ grep("Baseline",tracker$EVENT_ID)]="BL"
  tracker$date=NA
  momap=data.frame( num=c( paste0("0",1:9), "10", "11", "12") )
  rownames(momap)=c("JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC")
  for ( k in 1:nrow(tracker) ) {
    fixedev=unlist(strsplit( tracker$Visit[k], "/"))
    if ( length( fixedev ) > 1 ) fixedev=fixedev[length( fixedev )]
    tracker$EVENT_ID[k]=fixedev
    fixeddt = unlist(strsplit( tracker$Scan.Date[k],"-"))
    fixeddt[2] = momap[ fixeddt[2], 'num' ]
    fixeddt = paste0( fixeddt[3] , fixeddt[2], fixeddt[1] )
    tracker$date[k]=fixeddt
    }
  trackersub = tracker[, c("Subject.ID","date" )]
  trackersub$imaging_protocol=2
  names(trackersub)=c("PATNO","date", "imaging_protocol" )
  clin2b=merge( clin2b, trackersub, by=c("PATNO","date"), all.x=TRUE )
  clin2b$imaging_protocol[ is.na(clin2b$imaging_protocol) ]=1
  # add LRRK2 
  lrrk2 = read.csv( paste0(rdir,'CSFSAA_LRRK2_MRI_SAMPLES_08Jan2024/Data-Table1.csv'))
  lrrk2$SAAGroup[ lrrk2$SAAGroup == " " ]=NA
  clin2b$LRRK2_study=NA
  uids = lrrk2$PATNO
  lrrk2cols = colnames(lrrk2)
  lrrk2cols=lrrk2cols[ !(lrrk2cols %in% "PATNO") ]
  newcols = paste0("LRRK2_", lrrk2cols )
  clin2b[,newcols]=NA
  for ( k in 1:length(uids) ) {
    clin2bsel = clin2b$PATNO == uids[k]
    if ( sum( clin2bsel ) > 0 ) {
      # print(paste("have",u))
      clin2b[clin2bsel,newcols]=lrrk2[k,lrrk2cols]
    } # else print(paste("miss",u))
  }
  clin2b$LRRK2_study = !is.na( clin2b$LRRK2_cohort)
  summary( lm( LRRK2_MRIPROTOCOL ~ DTI_dti_tsnr_dwi_mean +T1Hier_evratio + noise + snr + msk_vol,data=clin2b) )
  summary( lm( LRRK2_MRIPROTOCOL ~ DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+DTI_dti_ssnr_dwi_mean+T1Hier_resnetGrade +T1Hier_evratio + cnr + noise,data=clin2b) )
  summary( lm( LRRK2_MRIPROTOCOL ~  cnr + noise  + msk_vol + spc0+	spc1+	spc2,data=clin2b) )
  clin2b$subjectID = as.character(clin2b$subjectID)
  clin2b$imageID = as.character(clin2b$imageID)
  clin2b$dtid1 = as.character(clin2b$dtid1)
  clin2b$dtid2 = as.character(clin2b$dtid2)
  clin2b$rsfid1 = as.character(clin2b$rsfid1)
  clin2b$rsfid2 = as.character(clin2b$rsfid2)
  clin2b=dplyr::bind_rows( clin2b, adni )
  nna=!is.na( clin2b$AsynStatus )
  clin2b$DXSubAsyn[nna]=paste0( clin2b$joinedDX[nna], clin2b$AsynStatus[nna] )
  clin2b$DXSubAsyn[ clin2b$DXSubAsyn == "NANegative"]=NA
  clin2b$commonEdu[ clin2b$commonEdu == 1] = 12
  clin2b$commonEdu[ clin2b$commonEdu == 2] = 16
  clin2b$commonEdu[ clin2b$commonEdu == 3] = 20
}
ppmi = clin2b
ppmi$T1Hier_midbrain_pons_ratio = ppmi$T1Hier_vol_midbrainbrainstem / ppmi$T1Hier_vol_ponsbrainstem
ppmi$SITE = factor( ppmi$SITE )
ppmi$brainVolume = ppmi$T1Hier_vol_hemisphere_lefthemispheres + ppmi$T1Hier_vol_hemisphere_righthemispheres
ppmi$brainVolume = ppmi$brainVolume / mean(ppmi$brainVolume)
ppmi$imaging_protocol[ ppmi$studyName=='ADNI']=3
ppmi$imaging_protocol=factor(ppmi$imaging_protocol)
ppmi[ ppmi$studyName=='ADNI', 'age_BL']=ppmi[ ppmi$studyName=='ADNI', 'AGE']

if ( TRUE ) {
  temp2=read.csv( '~/Documents/writing/ppmi_mri_scidata/src/data/temp_or.csv')
  ppmi$u_hier_id=NA
  for ( k in 1:nrow(ppmi) ) {
    ppmi$u_hier_id[k]=paste0( ppmi$studyName[k],ppmi$subjectID[k], ppmi$date[k], ppmi$imageID[k], collapse='-') 
  }
  ppmi=ppmi[ ppmi$u_hier_id %in% temp2$u_hier_id & ppmi$studyName == 'PPMI', ]
  temp2 = temp2[ temp2$studyName == 'PPMI', ]
  if ( myrez == 'SRF' ) {
    if ( all(ppmi$u_hier_id==temp2$u_hier_id) ) {
      ppmi$T1Hier_resnetGrade.SR=ppmi$T1Hier_resnetGrade
      ppmi$T1Hier_resnetGrade=temp2$T1Hier_resnetGrade # set rG to OR rG
    }
  }
  rm(temp2)
}
my500=read.csv("/Users/stnava/data/PPMI500/repo/PPMI500/ppmi500/ppmi500/data/ppmi500_ids_date.csv")
my500$iddate=NA
for ( k in 1:nrow(my500)) {
  my500$iddate[k]=paste0(my500$subjectID[k],"_",my500$date[k])
}
ppmi$iddate=NA
for ( k in 1:nrow(ppmi)) {
  ppmi$iddate[k]=paste0(ppmi$subjectID[k],"_",ppmi$date[k])
}
ppmi500=ppmi[ppmi$iddate %in% my500$iddate, ]
ppmi500$NM_QC_Ratings_BA=assign_qc_ratings_NM2DMT( ppmi500, lohi=c(0.3,0.7), verbose=TRUE )
```

```{r ppmiread500, echo=FALSE,eval=TRUE}
rdir = path.expand( "~/data/PPMI500/repo/PPMI500/presentation/" )
if ( ! exists("ppmi500" ) ) {
  ppmi500=read.csv( paste0( rdir, 'data/ppmi500_idps.csv' ) )
  ppmi500nmqc=assign_qc_ratings_NM2DMT( ppmi500, lohi = c(0.3, 0.7)  )
  ppmi500=antspymm_predictors(ppmi500,TRUE)
}

```

```{r tblprep,eval=TRUE,echo=FALSE,cache=FALSE}
###
toadd = c(  "age_BL", "commonSex", 'race', 'subgroup', 'hy_BL', 'duration_yrs', "updrs_totscore", 'AsynStatus', 'LEDD', 'imaging_protocol')
toadd = c(  "age_BL", "commonSex", 'subgroup', 'duration_yrs', "updrs_totscore", 'AsynStatus', 'LEDD' )
toadd = c(  "age_BL", "commonSex", 'duration_yrs', "updrs_totscore", 'AsynStatus', 'LEDD' )
tblcols = unique( c( toadd, 'joinedDX'  ) )
bsel = ppmi500$yearsbl==0 # & ppmi$studyName == 'PPMI'
joinedem=ppmi500[bsel,tblcols]
joinedem$hasDTI=!is.na(ppmi500[bsel,'DTI_dti_FD_mean'])
joinedem$hasfMRI=!is.na(ppmi500[bsel,'rsfMRI_fcnxpro129_FD_mean'])
names(joinedem)[1]=tblcols[1]='age'
names(joinedem)[2]=tblcols[2]='Sex'
wsaa=which(names(joinedem)=='AsynStatus' )
names(joinedem)[wsaa]=tblcols[wsaa]='CSFSAA'
tblcols=colnames(joinedem)
tblcols=gsub("_",".",tblcols)
tblcols=gsub(".mean","",tblcols)
tblcols=gsub("DTI.","",tblcols)
tblcols=gsub("rsfMRI.fcnxpro122.","rsfMRI.",tblcols)
names(joinedem)=tblcols
# joinedem$race = as.character( joinedem$race )
# joinedem[ is.na(joinedem$race), 'race' ] = 'not.spec.'
joinedem$joinedDX = gsub("Prodromal",'AR',joinedem$joinedDX)
joinedem$joinedDX=as.character(joinedem$joinedDX)
joinedem$joinedDX[ 
  multigrep( c("ARSporadic"), joinedem$joinedDX )]='SporadicAR'
joinedem$joinedDX[ 
  multigrep( c("ARGBA", "ARLRRK2",  "ARSNCA"), joinedem$joinedDX )]='GenAR'
joinedem$joinedDX[
  multigrep( c( "PDPRKN", "PDSNCA"), joinedem$joinedDX )]='OtherGenPD'
joinedem$joinedDX[ 
  multigrep( c("PDGBA"), joinedem$joinedDX )]='GBAPD'
joinedem$joinedDX[
  multigrep( c("PDLRRK2"), joinedem$joinedDX )]='LRRK2PD'
joinedem$joinedDX[ 
  multigrep( c("PDSporadic"), joinedem$joinedDX )]='SporadicPD'
mlevs = c( "CN", "GenAR", "SporadicAR","OtherGenPD", 'LRRK2PD', 'GBAPD', "SporadicPD")
joinedem$joinedDX = factor( joinedem$joinedDX, levels = mlevs )
mytbl = joinedem[ !is.na(joinedem$joinedDX),c(tblcols)]
rownames(mytbl)=1:nrow(mytbl)
mycap="Table 1. Baseline cohort for subjects with T1w IDPs and non-missing diagnosis."
####
```

# Overview 

We manually curated 500$+$ multiple modality PPMI MRI subjects. 5 messages from this effort.

1. Raw data quality is overall high 

  * visual inspection by humans

2. Processing improves quality/usability further 

  * failure rates humans vs processed

  * we provide scientists handles on this so that can be "strict" or "loose" in data selection

  * we document these parameters 

3. Detailed curation results provide a unique resource in itself

  * for algorithm developers 

    * we ourselves benefit from this (will show examples)

  * for scientists 

    * to have confidence (or at least context regarding quality) in looking at automated IDPs derived from these data


4. Enables investigation of the "meaning" of M3RI at the individual level 

5. Empowers investigation of the "meaning" of M3RI at the population level 


# the PPMI500 cohort 

  * Reviewing multiple modality data quality for current phase of collection

  * we collaborated on cohort definition

    * first phase - select subjects based on sampling from sites

    * second phase - select subjects based on population characteristics (MJFF/PPMI)

  * show table of summary cohort

```{r clusterCharARtbl,eval=TRUE,echo=FALSE,cache=FALSE,results='asis'}
turkey = mytbl[,tblcols]
turkey$joinedDX=as.character(turkey$joinedDX)
sttblPD=ztable(mytable(joinedDX~.,data=turkey),zebra=2)

# Print the ztable object, ensuring it's treated as LaTeX code
print(sttblPD, type = "html",size=5,caption=mycap,sidewaystable=TRUE)


```


```{r tbl1instead,eval=FALSE,echo=FALSE,cache=FALSE,results='asis'}
library(table1) # https://cran.r-project.org/web/packages/table1/vignettes/table1-latex.pdf
x=table1(~ . | joinedDX, data=mytbl[!is.na(mytbl$joinedDX),], topclass="Rtable1-zebra",caption=mycap)
t1kable(x)
```


# 1. Data quality is overall high

##  How do we define M3RI quality? 

* we manually QC'd each modality for each of 500 baseline subjects 

  * characterize reasons for failure 


## what is the QC protocol?

* Review QC protocol -- generally speaking 


## what are the QC results?

* Summarize QC results for each modality 

  * raw data QC and failure rates

* Summarize results for "joint" quality - how many subjects are high quality across *all modalities at once*?

## Tables of Manual QC results

```{r manqctbl,echo=FALSE,eval=TRUE,results='asis'}
failcolor='coral1'
succcolor='darkolivegreen'
failcolor='firebrick4'
succcolor='deepskyblue4'#  'dodgerblue1'
manqc=read.csv(paste0(rdir,'data/mergedhumanqc_full_AR_v0.0.2.csv'))[,-1]
manqc[manqc=='']=NA
manqc=manqc[ manqc$has_humanqc==1, ]
tblcols = colnames(manqc)[ !(colnames(manqc) %in%  c("subjectID","date" ,'id')) ]
turkey = manqc[,tblcols]
turkey = turkey[ turkey$modality %in% c("DTIb0","DTIdwi","rsfMRI","rsfMRI_LR","rsfMRI_RL","T1w","T2Flair","unknown"), ]

col2sel = getNamesFromDataframe("qchuman",manqc)
tct=2
qclist=list()
for ( ss in col2sel ) {
  turkey2=turkey[ !is.na( turkey[,ss] ), ]
  if ( ss == "qchuman_NM" ) {
    turkey2=ppmi500nmqc
    turkey2$modality='Neuromelanin'
  }
  if ( nrow(turkey2) > 0 ) {
    allna=rep(FALSE,ncol(turkey2))
    for ( k in 1:ncol(turkey2) ) {
    #  print(colnames(turkey2)[k])
    #  print(table( is.na(turkey2[,k])))
      allna[k]=sum( is.na(turkey2[,k]))==nrow(turkey2) 
    }
    turkey2=turkey2[,!allna]
    qclist[[gsub("qchuman_","",ss)]]=turkey2
    turkey2=turkey2[ , (colnames(turkey2)!='imageID')]
    mytt=mytable(modality~.,data=turkey2  )
    qcppmi=ztable(mytt,zebra=2)
    mycap=paste("Table ", tct, " Patterns of QC results by modality: ", gsub("qchuman_","",ss) )
    # Print the ztable object, ensuring it's treated as LaTeX code
    print(qcppmi, type = "html",size=4,caption=mycap,sidewaystable=TRUE)
    tct=tct+1
  }
}

```




### T1w results 

```{r t1summ,echo=FALSE,fig.width=6,fig.height=4}
library(tidyverse)
data = qclist[["T1w"]]
data = data[ data$has_humanqc == 1, ]
data[ is.na( data) ]='False'
data$qchuman_T1w=replace_values( data$qchuman_T1w, c("False",'True'), c(1,0) )
cols2rep=colnames(data)[3:5]
for ( col2rep in cols2rep ) {
  data[,col2rep]=replace_values( data[,col2rep], c("False",'True'), c(0,1) )
}
qclist[["T1w"]]=data
# Calculate success and failure rates
success_failure_data = calculate_success_failure_rates(data, "qchuman_T1w", "== 0", "== 1")
for ( mycc in c( colnames(data)[3:5]) ) {
  temp = calculate_success_failure_rates(data, mycc, "== 0", "== 1")
  success_failure_data=rbind(success_failure_data,temp)
}

plot_data <- success_failure_data %>%
  select(failcat, modality, Percent_Success, Percent_Failure) %>%
  pivot_longer(cols = c(Percent_Success, Percent_Failure), 
    names_to = "Outcome", values_to = "Percentage")

plot_data$failcat = forcats::fct_relevel( plot_data$failcat, unique(plot_data$failcat[grep("human",plot_data$failcat)]) )

# Plot
ggplot(plot_data, aes(x = failcat, y = Percentage, fill = Outcome )) +
  geom_bar(stat = "identity", position = "dodge" ) +
  scale_fill_manual(values = c("Percent_Success" = succcolor, "Percent_Failure" = failcolor)) +
  theme_minimal() +
  labs(title = "Success vs. Failure Rates by QC Cat: T1w",
       x = "Fail.Category",
       y = "Percentage",
       fill = "Outcome") + theme(legend.position='top',axis.text.x = element_text(angle = 45, hjust = 1))

# ggbarplot( plot_data, x='failcat', y='Percentage', color='modality', fill='Outcome' )
# ggbarplot( plot_data, x='failcat', y='Percentage', facet.by='modality', fill='Outcome' )
```


```{r,results='asis',echo=FALSE}
# temp=ztable(mytable(NM.QC.cat~.,data=plot_data),zebra=2)
# Print the ztable object, ensuring it's treated as LaTeX code
# print(temp, type = "html",size=5,caption='NM QC',sidewaystable=TRUE)

success_failure_data %>% 
  knitr::kable("html", booktabs = TRUE, caption=paste('T1w QC summary')) %>%
      kableExtra::kable_styling(latex_options = c("striped", "scale_down"))

```



### Flair results 

```{r flsumm,echo=FALSE,fig.width=6,fig.height=4}
library(tidyverse)
data = qclist[["FLAIR"]]
data = data[ data$has_humanqc == 1, ]
data[ is.na( data) ]='False'
data$qchuman_FLAIR=replace_values( data$qchuman_FLAIR, c("False",'True'), c(1,0) )
cols2rep=colnames(data)[3:7]
for ( col2rep in cols2rep ) {
  data[,col2rep]=replace_values( data[,col2rep], c("False",'True'), c(0,1) )
}
qclist[["FLAIR"]]=data
# Calculate success and failure rates
success_failure_data = calculate_success_failure_rates(data, "qchuman_FLAIR", "== 0", "== 1")
for ( mycc in c( colnames(data)[3:7]) ) {
  temp = calculate_success_failure_rates(data, mycc, "== 0", "== 1")
  success_failure_data=rbind(success_failure_data,temp)
}

plot_data <- success_failure_data %>%
  select(failcat, modality, Percent_Success, Percent_Failure) %>%
  pivot_longer(cols = c(Percent_Success, Percent_Failure), 
    names_to = "Outcome", values_to = "Percentage")

plot_data$failcat = forcats::fct_relevel( plot_data$failcat, unique(plot_data$failcat[grep("human",plot_data$failcat)]) )

# Plot
ggplot(plot_data, aes(x = failcat, y = Percentage, fill = Outcome)) +
  geom_bar(stat = "identity", position = "dodge" ) +
  scale_fill_manual(values = c("Percent_Success" = succcolor, "Percent_Failure" = failcolor)) +
  theme_minimal() +
  labs(title = "Success vs. Failure Rates by QC Cat: FLAIR",
       x = "Fail.Category",
       y = "Percentage",
       fill = "Outcome") + theme(legend.position='top',axis.text.x = element_text(angle = 45, hjust = 1))

# ggbarplot( plot_data, x='failcat', y='Percentage', color='modality', fill='Outcome' )
# ggbarplot( plot_data, x='failcat', y='Percentage', facet.by='modality', fill='Outcome' )
```


```{r,results='asis',echo=FALSE}
# temp=ztable(mytable(NM.QC.cat~.,data=plot_data),zebra=2)
# Print the ztable object, ensuring it's treated as LaTeX code
# print(temp, type = "html",size=5,caption='NM QC',sidewaystable=TRUE)

success_failure_data %>% 
  knitr::kable("html", booktabs = TRUE, caption=paste('FLAIR QC summary')) %>%
      kableExtra::kable_styling(latex_options = c("striped", "scale_down"))

```




### DT results 

```{r dtsumm,echo=FALSE,fig.width=9,fig.height=4}
library(tidyverse)
data = qclist[["DTI"]]
data = data[ data$has_humanqc == 1, ]
data[ is.na( data) ]='False'
data$qchuman_DTI=replace_values( data$qchuman_DTI, c("False",'True'), c(1,0) )
cols2rep=colnames(data)[3:8]
for ( col2rep in cols2rep ) {
  data[,col2rep]=replace_values( data[,col2rep], c("False",'True'), c(0,1) )
}
col2rep='qcfail_other'
data[,col2rep]=replace_values( data[,col2rep], c("False",'True'), c(0,1) )
data[,col2rep]=replace_values( data[,col2rep], c(0,'GHOSTING'), c(0,1) )
qclist[["DTI"]]=data
# table(data[,col2rep])
# Calculate success and failure rates
success_failure_data = calculate_success_failure_rates(data, "qchuman_DTI", "== 0", "== 1")
for ( mycc in c( colnames(data)[3:9]) ) {
  temp = calculate_success_failure_rates(data, mycc, "== 0", "== 1")
  success_failure_data=rbind(success_failure_data,temp)
}

plot_data <- success_failure_data %>%
  select(failcat, modality, Percent_Success, Percent_Failure) %>%
  pivot_longer(cols = c(Percent_Success, Percent_Failure), 
    names_to = "Outcome", values_to = "Percentage")

plot_data$failcat = forcats::fct_relevel( plot_data$failcat, unique(plot_data$failcat[grep("human",plot_data$failcat)]) )

# Plot
ggplot(plot_data, aes(x = failcat, y = Percentage, fill = Outcome, color=modality)) +
  geom_bar(stat = "identity", position = "dodge", linewidth = 0.75 ) +
  scale_fill_manual(values = c("Percent_Success" = succcolor, "Percent_Failure" = failcolor)) +
  theme_minimal() +
  labs(title = "Success vs. Failure Rates by QC Cat: DTI",
       x = "Fail.Category",
       y = "Percentage",
       fill = "Outcome") + theme(legend.position='top',axis.text.x = element_text(angle = 45, hjust = 1))

# ggbarplot( plot_data, x='failcat', y='Percentage', color='modality', fill='Outcome' )
# ggbarplot( plot_data, x='failcat', y='Percentage', facet.by='modality', fill='Outcome' )
```


```{r,results='asis',echo=FALSE}
# temp=ztable(mytable(NM.QC.cat~.,data=plot_data),zebra=2)
# Print the ztable object, ensuring it's treated as LaTeX code
# print(temp, type = "html",size=5,caption='NM QC',sidewaystable=TRUE)

success_failure_data %>% 
  knitr::kable("html", booktabs = TRUE, caption=paste('DTI QC summary')) %>%
      kableExtra::kable_styling(latex_options = c("striped", "scale_down"))

```




### rsfMRI results 

```{r rsfsumm,echo=FALSE,fig.width=9.6,fig.height=4}
library(tidyverse)
data = qclist[["rsfMRI"]]
data = data[ data$has_humanqc == 1, ]
data[ is.na( data) ]='False'
data$qchuman_rsfMRI=replace_values( data$qchuman_rsfMRI, c("False",'True'), c(1,0) )
cols2rep=colnames(data)[3:11]
for ( col2rep in cols2rep ) {
  data[,col2rep]=replace_values( data[,col2rep], c("False",'True'), c(0,1) )
}
col2rep='qcfail_other'
data[,col2rep]=replace_values( data[,col2rep], c("False",'True'), c(0,1) )
for ( x in unique(data$qcfail_other)[2:5] ) {
  data[,col2rep]=replace_values( data[,col2rep], c(x,'True'), c(0,1) )
  }
qclist[["rsfMRI"]]=data
# Calculate success and failure rates
success_failure_data = calculate_success_failure_rates(data, "qchuman_rsfMRI", "== 0", "== 1")
for ( mycc in c( colnames(data)[3:11]) ) {
  temp = calculate_success_failure_rates(data, mycc, "== 0", "== 1")
  success_failure_data=rbind(success_failure_data,temp)
}

plot_data <- success_failure_data %>%
  select(failcat, modality, Percent_Success, Percent_Failure) %>%
  pivot_longer(cols = c(Percent_Success, Percent_Failure), 
    names_to = "Outcome", values_to = "Percentage")

plot_data$failcat = forcats::fct_relevel( plot_data$failcat, unique(plot_data$failcat[grep("human",plot_data$failcat)]) )

# Plot
ggplot(plot_data, aes(x = failcat, y = Percentage, fill = Outcome, color=modality)) +
  geom_bar(stat = "identity", position = "dodge", linewidth = 0.75 ) +
  scale_fill_manual(values = c("Percent_Success" = succcolor, "Percent_Failure" = failcolor)) +
  theme_minimal() +
  labs(title = "Success vs. Failure Rates by QC Cat: rsfMRI",
       x = "Fail.Category",
       y = "Percentage",
       fill = "Outcome") + theme(legend.position='top',axis.text.x = element_text(angle = 45, hjust = 1))

# ggbarplot( plot_data, x='failcat', y='Percentage', color='modality', fill='Outcome' )
# ggbarplot( plot_data, x='failcat', y='Percentage', facet.by='modality', fill='Outcome' )
```


```{r,results='asis',echo=FALSE}
# temp=ztable(mytable(NM.QC.cat~.,data=plot_data),zebra=2)
# Print the ztable object, ensuring it's treated as LaTeX code
# print(temp, type = "html",size=5,caption='NM QC',sidewaystable=TRUE)

success_failure_data %>% 
  knitr::kable("html", booktabs = TRUE, caption=paste('rsfMRI QC summary')) %>%
      kableExtra::kable_styling(latex_options = c("striped", "scale_down"))

```



### NM results 

```{r nmsumm,echo=FALSE,fig.width=6,fig.height=3}
library(tidyverse)
data = na.omit(qclist[["NM"]])
# Calculate success and failure rates
success_failure_data = calculate_success_failure_rates(data, "NM_QC_Ratings_Failures", "== 0", "> 0")
success_failure_data_z = calculate_success_failure_rates(data, "NM_QC_Ratings_Z", "== 1", "== 0")

success_failure_data_vol = calculate_success_failure_rates(data, "NM_QC_Ratings_SNVol", "== 1", "== 0")
success_failure_data_int = calculate_success_failure_rates(data, "NM_QC_Ratings_AvgIntensity", "== 1", "== 0")
success_failure_data_sdint = calculate_success_failure_rates(data, "NM_QC_Ratings_SDIntensity", "== 1", "== 0")
success_failure_data_max = calculate_success_failure_rates(data, "NM_QC_Ratings_MaxIntensity", "== 1", "== 0")

all_fail = rbind( 
  success_failure_data,
  success_failure_data_z,
  success_failure_data_vol,  
  success_failure_data_int,
  success_failure_data_sdint,
  success_failure_data_max )

plot_data <- all_fail %>%
  select(failcat, Percent_Success, Percent_Failure) %>%
  pivot_longer(cols = c(Percent_Success, Percent_Failure), 
    names_to = "Outcome", values_to = "Percentage")
colnames(plot_data)[1]='NM.QC.cat'
plot_data$NM.QC.cat=c(
  "overall","overall",
  "z.coord","z.coord",
  'sn.vol','sn.vol',
  'avg.int','avg.int',
  'sd.int','sd.int',
  'max.int','max.int')

plot_data$NM.QC.cat = forcats::fct_relevel( plot_data$NM.QC.cat, 'overall')

# Plot
ggplot(plot_data, aes(x = NM.QC.cat, y = Percentage, fill = Outcome)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = c("Percent_Success" = succcolor, "Percent_Failure" = failcolor)) +
  theme_minimal() +
  labs(title = "Success vs. Failure Rates by QC Cat: NM",
       x = "NM.QC.cat",
       y = "Percentage",
       fill = "Outcome") + theme(legend.position='top')

```


```{r,results='asis',echo=FALSE}
# temp=ztable(mytable(NM.QC.cat~.,data=plot_data),zebra=2)
# Print the ztable object, ensuring it's treated as LaTeX code
# print(temp, type = "html",size=5,caption='NM QC',sidewaystable=TRUE)
colnames(all_fail)[1]='NM.QC.cat'
all_fail$NM.QC.cat=c(
  "overall","z.coord",'sn.vol','avg.int','sd.int','max.int')

all_fail %>% 
  knitr::kable("html", booktabs = TRUE, caption=paste('NM QC summary')) %>%
      kableExtra::kable_styling(latex_options = c("striped", "scale_down"))

```


```{r mergetqctoppmi500,echo=FALSE,fig.width=9,fig.height=4}
myMode <- function(x) {
    ux <- unique(x)
    ux[which.max(tabulate(match(x, ux)))]
    }
mostfreq <- function( x, na.rm=TRUE ) {
    if ( is.numeric( x ) ) return( mean(x,na.rm=na.rm ) )
    return( myMode( x ) )
  }

qchcols=getNamesFromDataframe("qchuman",ppmi500)
if ( length(qchcols) > 0  ) {
  ppmi500=ppmi500[ , !(colnames(ppmi500) %in% qchcols )]
}

qclist[["NM"]]$qchuman_NM=NA
qclist[["NM"]]$qchuman_NM[ subtyper::fs( qclist[["NM"]]$NM_QC_Ratings_Failures == 0 ) ]=0
qclist[["NM"]]$qchuman_NM[ subtyper::fs( qclist[["NM"]]$NM_QC_Ratings_Failures > 0 ) ]=1
temp = merge( ppmi500, qclist[["T1w"]][,c("imageID","qchuman_T1w")], by='imageID', all.x=TRUE)
temp2=qclist[["FLAIR"]][,c("imageID","qchuman_FLAIR")]
colnames(temp2)[1]='flairid'
temp = merge( temp, temp2, by='flairid', all.x=TRUE)


temp2=qclist[["DTI"]][,c("imageID","qchuman_DTI")]
uids = unique( c( temp$dtid1, temp$dtid2 ) )
temp2$qchuman_DTI=as.numeric(temp2$qchuman_DTI)
# table( uids %in% qclist[["DTI"]]$imageID )
temp$qchuman_DTI=NA
for ( u in uids ) {
  ww = which( temp2$imageID == u )
  if ( length (ww ) > 0 ) {
    puthere = which( temp$dtid1 == u )
    if ( length(puthere) == 0 ) puthere = which( temp$dtid2 == u )
    if ( is.na( temp$qchuman_DTI[puthere] )) {
      temp$qchuman_DTI[puthere] = max( temp2[ww,'qchuman_DTI'])
    } else temp$qchuman_DTI[puthere] = temp$qchuman_DTI[puthere]+max( temp2[ww,'qchuman_DTI'])
  }
}

temp2=qclist[["rsfMRI"]][,c("imageID","qchuman_rsfMRI")]
uids = unique( c( temp$rsfid1, temp$rsfid2 ) )
temp2$qchuman_rsfMRI=as.numeric(temp2$qchuman_rsfMRI)
temp$qchuman_rsfMRI=NA
for ( u in uids ) {
  ww = which( temp2$imageID == u )
  if ( length (ww ) > 0 ) {
    puthere = which( temp$rsfid1 == u )
    if ( length(puthere) == 0 ) puthere = which( temp$rsfid2 == u )
    if ( is.na( temp$qchuman_rsfMRI[puthere] )) {
      temp$qchuman_rsfMRI[puthere] = max( temp2[ww,'qchuman_rsfMRI'])
    } else temp$qchuman_rsfMRI[puthere] = temp$qchuman_rsfMRI[puthere]+max( temp2[ww,'qchuman_rsfMRI'])
  }
}


# temp2=aggregate( qchuman_DTI ~ imageID, temp2, median ) 
# colnames(temp2)[1]='dtid1'
# temp = merge( temp, temp2, by='dtid1', all.x=TRUE)
# colnames(temp2)[1]='dtid2'
# temp = merge( temp, temp2, by='dtid2', all.x=TRUE)
#temp2=qclist[["rsfMRI"]][,c("imageID","qchuman_rsfMRI")]
#temp2=aggregate( qchuman_rsfMRI ~ imageID, temp2, mostfreq ) 
#colnames(temp2)[1]='rsfid1'
#temp = merge( temp, temp2, by='rsfid1', all.x=TRUE)
#colnames(temp2)[1]='rsfid2'
#temp = merge( temp, temp2, by='rsfid2', all.x=TRUE)


temp$qchuman_NM=qclist[["NM"]]$qchuman_NM # these were calculated directly from ppmi500
qchcols=getNamesFromDataframe("qchuman",temp)
if ( ! ( all( qchcols %in% colnames(ppmi500))) ) {
  ppmi500=temp
}

success_failure_data = calculate_success_failure_rates(ppmi500, qchcols[1], "== 0", ">= 1")
for ( mycc in qchcols[-1] ) {
  temp = calculate_success_failure_rates(ppmi500, mycc, "== 0", ">= 1")
  success_failure_data=rbind(success_failure_data,temp)
}

success_failure_data$modality=c("T1w",'FLAIR',"DTI","rsfMRI","NM")


plot_data <- success_failure_data %>%
  select(failcat, modality, Percent_Success, Percent_Failure) %>%
  pivot_longer(cols = c(Percent_Success, Percent_Failure), 
    names_to = "Outcome", values_to = "Percentage")

plot_data$failcat = forcats::fct_relevel( plot_data$failcat, unique(plot_data$failcat[grep("human",plot_data$failcat)]) )

# Plot
ggplot(plot_data, aes(x = failcat, y = Percentage, fill = Outcome, color=modality)) +
  geom_bar(stat = "identity", position = "dodge", linewidth = 0.75 ) +
  scale_fill_manual(values = c("Percent_Success" = succcolor, "Percent_Failure" = failcolor)) +
  theme_minimal() +
  labs(title = "Success vs. Failure Rates by QC Cat: All",
       x = "Fail.Category",
       y = "Percentage",
       fill = "Outcome") + theme(legend.position='top',axis.text.x = element_text(angle = 45, hjust = 1))

# now write this out 
# nnas=rep(0,ncol(ppmi500))
# for ( k in 1:ncol(ppmi500 )) nnas[k]=sum(is.na(ppmi500[,k]))
# write.csv( ppmi500[,nnas < 333], 'data/ppmi500_idps.csv', row.names=FALSE )

```


## do a check based on rsfmri motion -- if the qc data "makes sense"


```{r fmrimotion,echo=FALSE,eval=TRUE,fig.width=12,fig.height=6}

ppmi500$rsfqc= as.numeric( ppmi500$qchuman_rsfMRI )
slit = subtyper::fs(ppmi500$T1Hier_resnetGrade > 1.02)
ppmi500sel=ppmi500[ slit & !is.na(ppmi500$rsfqc), ]

xcl=c('winz','threshold','original')
nuisnames = unique( c( 
  getNamesFromDataframe( c("rsfMRI","122","snr"), ppmi500sel, exclusions=xcl),
  getNamesFromDataframe( c("rsfMRI","122","FD"), ppmi500sel, exclusions=xcl),
  getNamesFromDataframe( c("rsfMRI","122","minutes"), ppmi500sel, exclusions=xcl),
  getNamesFromDataframe( c("rsfMRI","122","despik"), ppmi500sel, exclusions=xcl ),
  getNamesFromDataframe( c("rsfMRI","122","evr"), ppmi500sel, exclusions=xcl)))
for ( n in nuisnames ) {
  nn=paste0(n,"_winz")
  nn=gsub("rsfMRI_fcnxpro122_","fmri.",nn)
  if ( length(grep("minutes",n) > 0 ) ) {
    ppmi500sel[,nn]=ppmi500sel[,n]
    ppmi500sel[ subtyper::fs(ppmi500sel[,nn] > 10) ,nn]=ppmi500sel[ subtyper::fs(ppmi500sel[,nn] > 10) ,nn]-5
  } else ppmi500sel[,nn]=psych::winsor( ppmi500sel[,n], 0.01 )
}
nuisnames=getNamesFromDataframe(c("fmri.","_winz"),ppmi500sel)
mform = paste( "rsfqc ~ ", paste( nuisnames, collapse='+') )
mdl=lm(  mform , data=ppmi500sel)
mygrobs=visreg::visreg(mdl,gg=TRUE)
for ( g in 1:length(mygrobs) ) mygrobs[[g]]=mygrobs[[g]]+theme_minimal()+
    theme(axis.title.x = element_text(size = 14),
          axis.title.y = element_text(size = 14))
grid.arrange( grobs=mygrobs, nrow=2, top='QC vs automatic nuisance covariates') 

rsfvar="rsfMRI_fcnxpro122_SomMotA_2_ContC"
temp=ppmi500sel
temp$commonAge=as.numeric(scale(temp$commonAge))
temp$cnxvar=temp[,rsfvar]
mform = paste( "cnxvar ~ 1 +", paste( nuisnames, collapse='+') )
mdlF=lm(   mform , data=temp)
mygrobs=visreg::visreg(mdlF,gg=TRUE)
for ( g in 1:length(mygrobs) ) mygrobs[[g]]=mygrobs[[g]]+theme_minimal()+
    theme(axis.title.x = element_text(size = 14),
          axis.title.y = element_text(size = 14))
grid.arrange( grobs=mygrobs, nrow=2, 
  top=paste('Connectivity vs nuisance and QC: pass and fail R^2',
    insight::format_value(rsq(mdlF,adj=T),digits=3)))

mform = paste( "cnxvar ~  ", paste( nuisnames, collapse='+') )
tempx=temp[temp$rsfqc==0,]
mdlP=lm(   mform , data=tempx)
mygrobs=visreg::visreg(mdlP,gg=TRUE)
for ( g in 1:length(mygrobs) ) mygrobs[[g]]=mygrobs[[g]]+theme_minimal()+
    theme(axis.title.x = element_text(size = 14),
          axis.title.y = element_text(size = 14))
#grid.arrange( grobs=mygrobs, nrow=2, 
 # top=paste('Connectivity vs nuisance and QC: pass only R^2',insight::format_value(rsq(mdlP,adj=T),digits=3)))


mform = paste( "cnxvar ~ DXSubAsyn+commonAge+commonSex+ fmri.despiking_count_summary_winz+fmri.ssnr_mean_winz+fmri.FD_max_winz")
tempx=temp[temp$fmri.FD_max_winz<=1.5,]
mdlD=lm(   mform , data=tempx)
tempx=temp[temp$rsfqc==0,]
mdlD2=lm(   mform , data=tempx)
mygrobs2=visreg::visreg(mdlD,gg=TRUE)
for ( g in 1:length(mygrobs2) ) mygrobs2[[g]]=mygrobs2[[g]]+theme_minimal()+
    theme(axis.title.x = element_text(size = 14),
          axis.title.y = element_text(size = 14))
#grid.arrange( grobs=mygrobs2, nrow=2, 
 # top=paste('Connectivity vs nuisance and QC & DX: pass only R^2',insight::format_value(rsq(mdlD,adj=T),digits=3)))
  mlist = list( passAndFail=mdlF, passOnly=mdlP, AutoQC=mdlD, ManQC=mdlD2 )
  mlfun = function( x ) length( x$fitted.values )
  maxf = unlist( lapply( mlist, mlfun ) )
  for ( jj in 1:length(mlist)) {
    nm=names(mlist)[jj]
    names(mlist)[jj]=paste0(nm,"_",round(maxf[jj]/max(maxf)*100))
  }

print( modelplot( mlist, 
  conf_level = .95, coef_omit = "nterc|tsnr|despik|FD_mean|evr|LRR")
  + ggtitle( paste("rsfMRI Models: All vs Pass vs AutoQC+DX + ManQC+DX \n (select covars shown)") )
  +    theme(
          plot.title = element_text(size = 20),
          axis.title.x = element_text(size = 18),
          axis.title.y = element_text(size = 18), 
          axis.text.x = element_text(size = 15), 
          axis.text.y = element_text(size = 15)) )
# summary(mdlF)
# summary(mdlP)

```




## do a check based on DTI -- if the qc data "makes sense"


```{r dtiqccheck,echo=FALSE,eval=TRUE,fig.width=12,fig.height=6}

ppmi500$dtiqc=as.numeric( ppmi500$qchuman_DTI )
slit = subtyper::fs(ppmi500$T1Hier_resnetGrade > 1.02)
ppmi500sel=ppmi500[ slit & !is.na(ppmi500$dtiqc), ]

xcl=c('winz','threshold','original','rsfMR','cnxc')
nuisnames = unique( c( 
  getNamesFromDataframe( c("DTI","tsnr"), ppmi500sel, exclusions=xcl),
  getNamesFromDataframe( c("DTI","ssnr"), ppmi500sel, exclusions=xcl),
  getNamesFromDataframe( c("DTI","FD"), ppmi500sel, exclusions=xcl),
  getNamesFromDataframe( c("DTI","evr"), ppmi500sel, exclusions=xcl)))
for ( n in nuisnames ) {
  nn=paste0(n,"_winz")
  nn=gsub("DTI_dti_","dti.",nn)
  ppmi500sel[,nn]=psych::winsor( ppmi500sel[,n], 0.01 )
}
slfasym=getNamesFromDataframe( c("DTI","cap","LR"), ppmi500 )[1]
slfasym=getNamesFromDataframe( c("DTI","orpus","LR"), ppmi500 )[2]
nuisnames=getNamesFromDataframe(c("dti.","_winz"),ppmi500sel,exclusions='tsnr')
mform = paste( "dtiqc ~ ", paste( nuisnames, collapse='+') )
tempx=ppmi500sel
tempx=scale_variables_in_equation( tempx, mform)
mdl=lm(   mform , data=tempx)
mygrobs=visreg::visreg(mdl,gg=TRUE)
for ( g in 1:length(mygrobs) ) mygrobs[[g]]=mygrobs[[g]]+theme_minimal()+
      theme(axis.title.x = element_text(size = 14),
            axis.title.y = element_text(size = 14))
grid.arrange( grobs=mygrobs, nrow=2, top='QC vs automatic nuisance covariates') 

  #grid.arrange( grobs=mygrobs, nrow=2, 
  # top=paste('Connectivity vs nuisance and QC: pass only R^2',insight::format_value(rsq(mdlP,adj=T),digits=3)))

for ( slfasym in  getNamesFromDataframe( c("DTI","orpus"), ppmi500 ) ) {
  temp=ppmi500sel
  temp$cnxvar=temp[,slfasym]
  temp$commonAge=as.numeric(scale(temp$commonAge))
  mform = paste( "cnxvar ~ 1 +", paste( nuisnames, collapse='+') )
  temp=scale_variables_in_equation( temp, mform)
  mdlF=lm(   mform , data=temp)
  mygrobs=visreg::visreg(mdlF,gg=TRUE)
  for ( g in 1:length(mygrobs) ) mygrobs[[g]]=mygrobs[[g]]+theme_minimal()+
      theme(axis.title.x = element_text(size = 14),
            axis.title.y = element_text(size = 14))
  grid.arrange( grobs=mygrobs, nrow=2, 
    top=paste('DTI IDP vs nuisance and QC: pass and fail R^2',
      insight::format_value(rsq(mdlF,adj=T),digits=3)))

  mform = paste( "cnxvar ~  ", paste( nuisnames, collapse='+') )
  tempx=temp[temp$dtiqc==0,]
  tempx=scale_variables_in_equation( tempx, mform)
  mdlP=lm(   mform , data=tempx)
  mygrobs=visreg::visreg(mdlP,gg=TRUE)
  for ( g in 1:length(mygrobs) ) mygrobs[[g]]=mygrobs[[g]]+theme_minimal()+
      theme(axis.title.x = element_text(size = 14),
            axis.title.y = element_text(size = 14))

  mform = paste( "cnxvar ~ joinedDX+commonAge+commonSex+dti.ssnr_b0_mean_winz+
    dti.FD_mean_winz+dti.FD_max_winz+dti.ssnr_dwi_mean_winz+dti.fa_evr_winz")
  mform = paste( "cnxvar ~ DXSubAsyn+commonAge+commonSex+brainVolume+
  dti.ssnr_b0_mean_winz+ dti.tsnr_b0_mean_winz+ dti.FD_mean_winz+dti.FD_max_winz+dti.fa_evr_winz")
  # tempx=temp[temp$dti.FD_max_winz<=8,]
  tempx=temp[temp$dti.FD_mean_winz<=5,]
  tempx=scale_variables_in_equation( tempx, mform)
  mdlD=lm(   mform , data=tempx)
  tempx=temp[temp$dtiqc==0,]
  mdlD2=lm(   mform , data=tempx)
  mygrobs2=visreg::visreg(mdlD,gg=TRUE)
  for ( g in 1:length(mygrobs2) ) mygrobs2[[g]]=mygrobs2[[g]]+theme_minimal()+
      theme(axis.title.x = element_text(size = 14),
            axis.title.y = element_text(size = 14))
  #grid.arrange( grobs=mygrobs2, nrow=2, 
  # top=paste('Connectivity vs nuisance and QC & DX: pass only R^2',insight::format_value(rsq(mdlD,adj=T),digits=3)))
  mlist = list( passAndFail=mdlF, passOnly=mdlP, AutoQC=mdlD, ManQC=mdlD2 )
  maxf = unlist( lapply( mlist, mlfun ) )
  for ( jj in 1:length(mlist)) {
    nm=names(mlist)[jj]
    names(mlist)[jj]=paste0(nm,"_",round(maxf[jj]/max(maxf)*100))
  }

  print( modelplot( mlist, 
    conf_level = .95, coef_omit = "nterc|LRR|CNP|brainVolume|tsnr")
    + ggtitle( paste("DTI Models: All vs Pass vs AutoQC+DX + ManQC+DX \n (select covars shown)",shorten_pymm_names(slfasym)) )
    +    theme(
            plot.title = element_text(size = 20),
            axis.title.x = element_text(size = 18),
            axis.title.y = element_text(size = 18), 
            axis.text.x = element_text(size = 15), 
            axis.text.y = element_text(size = 15)) )
}
  # summary(mdlF)
# summary(mdlP)

```





## do a check based on NM -- if the qc data "makes sense"

```{r nmqccheck,echo=FALSE,eval=TRUE,fig.width=12,fig.height=6}

slit = subtyper::fs(ppmi500$T1Hier_resnetGrade > 1.02)
ppmi500sel=ppmi500[ slit & !is.na(ppmi500$NM_QC_Ratings_BA), ]

xcl=c('winz','threshold','original','rsfMR','cnxc')
nuisnames = c("NM2DMT_NM_avg_signaltonoise","NM2DMT_NM_evr", "NM2DMT_NM_q0pt10", "NM2DMT_NM_q0pt90",
  "NM2DMT_NM_q0pt05", "NM2DMT_NM_q0pt95",
  "NM2DMT_NM_sd","NM2DMT_NM_substantianigra_z_coordinate","NM2DMT_NM_count")
nuisnames = c("NM2DMT_NM_evr", 
#  "NM2DMT_NM_q0pt10", "NM2DMT_NM_q0pt90", "NM2DMT_NM_q0pt05", "NM2DMT_NM_q0pt95",
  "NM2DMT_NM_sd","NM2DMT_NM_substantianigra_z_coordinate","NM2DMT_NM_count")
# nuisnames = c("NM2DMT_NM_substantianigra_z_coordinate","NM2DMT_NM_count")
nuisnames=c("NM2DMT_NM_max", "NM2DMT_NM_q0pt10", "NM2DMT_NM_q0pt90", "NM2DMT_NM_q0pt05", "NM2DMT_NM_q0pt95","NM2DMT_NM_min","NM2DMT_NM_count","NM2DMT_NM_substantianigra_z_coordinate")
for ( n in nuisnames ) {
  nn=paste0(n,"_winz")
  nn=gsub("NM2DMT_NM_","nm.",nn)
  ppmi500sel[,nn]=psych::winsor( ppmi500sel[,n], 0.0 )
}


nuisnames=getNamesFromDataframe(c("nm.","_winz"),ppmi500sel,exclusions='tsnr')
mform = paste( "NM_QC_Ratings_BA ~ ", paste( nuisnames, collapse='+') )
tempx=ppmi500sel
tempx=scale_variables_in_equation( tempx, mform)
mdl=lm(   mform , data=tempx)
mygrobs=visreg::visreg(mdl,gg=TRUE)
for ( g in 1:length(mygrobs) ) mygrobs[[g]]=mygrobs[[g]]+theme_minimal()+
      theme(axis.title.x = element_text(size = 14),
            axis.title.y = element_text(size = 14))

grid.arrange( grobs=mygrobs, nrow=2, top='QC vs automatic nuisance covariates') 

  #grid.arrange( grobs=mygrobs, nrow=2, 
  # top=paste('Connectivity vs nuisance and QC: pass only R^2',insight::format_value(rsq(mdlP,adj=T),digits=3)))

temp=ppmi500sel
temp$nmvar = ( temp$NM2DMT_NM_avg_substantianigra - temp$NM2DMT_NM_avg_refregion )# /temp$NM2DMT_NM_sd
temp$nmvar = ( temp$NM2DMT_NM_avg_substantianigra  ) / temp$NM2DMT_NM_sd
#  ( temp$NM2DMT_NM_q0pt90 - temp$NM2DMT_NM_q0pt10 )
# temp = temp[ temp$nmvar < 0.75, ]
temp$commonAge=as.numeric(scale(temp$commonAge))
mform = paste( "nmvar ~ 1 +", paste( nuisnames, collapse='+') )
temp=scale_variables_in_equation( temp, mform)
mdlF=lm(   mform , data=temp)
mygrobs=visreg::visreg(mdlF,gg=TRUE)
for ( g in 1:length(mygrobs) ) mygrobs[[g]]=mygrobs[[g]]+theme_minimal()+
      theme(axis.title.x = element_text(size = 14),
            axis.title.y = element_text(size = 14))

```

```{r nmqccheck2,echo=FALSE,eval=TRUE,fig.width=12,fig.height=6}
grid.arrange( grobs=mygrobs, nrow=2, 
    top=paste('NM IDP vs nuisance and QC: pass and fail R^2',
      insight::format_value(rsq(mdlF,adj=T),digits=3)))

mform = paste( "nmvar ~  ", paste( nuisnames, collapse='+') )
tempx=temp[temp$NM_QC_Ratings_BA==1,]
tempx=scale_variables_in_equation( tempx, mform)
mdlP=lm(   mform , data=tempx)
mygrobs=visreg::visreg(mdlP,gg=TRUE)
for ( g in 1:length(mygrobs) ) mygrobs[[g]]=mygrobs[[g]]+theme_minimal()+
      theme(axis.title.x = element_text(size = 14),
            axis.title.y = element_text(size = 14))


nuisnames2=nuisnames[-grep("sd",nuisnames)]
dxsel=c("CNNegative","PDSporadicPositive","ProdromalSporadicPositive")
mform = paste( "nmvar ~ DXSubAsyn+commonAge+commonSex+brainVolume+", paste( nuisnames, collapse='+'))
tempx=temp[temp$NM2DMT_NM_sd < 27.5 & temp$NM2DMT_NM_sd > 17.5 & temp$DXSubAsyn %in% dxsel,]
tempx=scale_variables_in_equation( tempx, mform)
mdlD=lm(   mform , data=tempx)
tempx=temp[temp$NM_QC_Ratings_BA==1& temp$DXSubAsyn %in% dxsel,]
tempx=scale_variables_in_equation( tempx, mform)
mdlD2=lm(   mform , data=tempx)


print( jtools::effect_plot( mdlD,'DXSubAsyn' ) +theme(legend.position='top',axis.text.x = element_text(angle = 45, hjust = 1)) )
cat("\n\n\n\n\n\n")
#grid.arrange( grobs=mygrobs2, nrow=2, 
# top=paste('Connectivity vs nuisance and QC & DX: pass only R^2',insight::format_value(rsq(mdlD,adj=T),digits=3)))
mlist=list( passAndFail=mdlF, passOnly=mdlP, AutoQC=mdlD, ManQC=mdlD2 )
  maxf = unlist( lapply( mlist, mlfun ) )
for ( jj in 1:length(mlist)) {
    nm=names(mlist)[jj]
    names(mlist)[jj]=paste0(nm,"_",round(maxf[jj]/max(maxf)*100))
  }



print( modelplot( mlist, 
    conf_level = .95, coef_omit = "nterc|snr|LRR|CNP|brainVolume|sd|q0|max|min")
    + ggtitle( paste("NM models: All vs Pass vs AutoQC+DX + ManQC+DX \n (select covars shown)") )
    +    theme(
            plot.title = element_text(size = 20),
            axis.title.x = element_text(size = 18),
            axis.title.y = element_text(size = 18), 
            axis.text.x = element_text(size = 15), 
            axis.text.y = element_text(size = 15)) )



# summary(mdlF)
# summary(mdlP)


```






## do a check based on FLAIR -- if the qc data "makes sense"


```{r flairqccheck,echo=FALSE,eval=TRUE,fig.width=12,fig.height=6}

slit = subtyper::fs(ppmi500$T1Hier_resnetGrade > 1.02)
ppmi500sel=ppmi500[ slit & !is.na(ppmi500$qchuman_FLAIR), ]

xcl=c('winz','threshold','original','rsfMR','cnxc')
nuisnames = c("T2Flair_flair_evr","T2Flair_flair_SNR")

mform=paste0( "T2Flair_flair_wmh_prior~DXSubAsyn+brainVolume+commonAge+commonSex+",paste(nuisnames,collapse='+'))
ppmi500sel=scale_variables_in_equation(ppmi500sel,mform)
tempPass=ppmi500sel[ppmi500sel$qchuman_FLAIR==0,]
tempFail=ppmi500sel[,]
mdlMan=lm(mform,data=tempPass)
mdlAuto=lm(mform,data=tempFail)
mlist = list(  AutoQC=mdlAuto, ManQC=mdlMan )
  maxf = unlist( lapply( mlist, mlfun ) )
  for ( jj in 1:length(mlist)) {
    nm=names(mlist)[jj]
    names(mlist)[jj]=paste0(nm,"_",round(maxf[jj]/max(maxf)*100))
  }
print( modelplot( mlist, 
    conf_level = .95, coef_omit = "nterc|evr|LRR|brainV")
    + ggtitle( paste("FLAIR Models: All vs Pass vs AutoQC+DX + ManQC+DX \n (select covars shown) WM hyperintensity") )
    +    theme(
            plot.title = element_text(size = 20),
            axis.title.x = element_text(size = 18),
            axis.title.y = element_text(size = 18), 
            axis.text.x = element_text(size = 15), 
            axis.text.y = element_text(size = 15)) )

```







## do a check based on T1w -- if the qc data "makes sense"


```{r t1wqccheck,echo=FALSE,eval=TRUE,fig.width=12,fig.height=6}

ppmi500sel=ppmi500[ !is.na(ppmi500$qchuman_T1w), ]
nuisnames = c("noise","psnr","ssim","mi","reflection_err","EVR","msk_vol","spc0","spc1","spc2")

vois=c("T1Hier_vol_mtg_sn_snc_LRAVGcit168",
  "T1Hier_vol_bn_str_pu_Asymdeep_cit168",
  "T1Hier_vol_bn_gp_gpe_LRAVGdeep_cit168","T1Hier_vol_LRAVG_dg.ca3mtl")
for ( voi in vois ) {
  mform=paste0( voi,"~DXSubAsyn+brainVolume+commonAge+commonSex+",paste(nuisnames,collapse='+'))
  ppmi500sel=scale_variables_in_equation(ppmi500sel,mform)
  tempPass=ppmi500sel[ppmi500sel$qchuman_T1w==0,]
  tempAll=ppmi500sel
  tempFail=ppmi500sel[ppmi500sel$T1Hier_resnetGrade > 0.5,]
  tempAutoQC=ppmi500sel[ppmi500sel$T1Hier_resnetGrade > 1.05,]
  mdlAll=lm(mform,data=tempAll)
  mdlAutoFail=lm(mform,data=tempFail)
  mdlAuto=lm(mform,data=tempAutoQC)
  mdlMan=lm(mform,data=tempPass)
  mlist = list(  
    NoCuration=mdlAll, 
    AutoDetectFail=mdlAutoFail, 
    AutoQC=mdlAuto, ManQC=mdlMan )
  maxf = unlist( lapply( mlist, mlfun ) )
  for ( jj in 1:length(mlist)) {
    nm=names(mlist)[jj]
    names(mlist)[jj]=paste0(nm,"_",round(maxf[jj]/max(maxf)*100))
  }
  print( modelplot( mlist, 
      conf_level = .95, coef_omit = "nterc|evr|LRR|spc|brainV|CNP")
      + ggtitle( paste("T1w Models: All vs Permissive vs AutoQC + ManQC \n (select covars shown)", shorten_pymm_names(voi)) )
      +    theme(
              plot.title = element_text(size = 20),
              axis.title.x = element_text(size = 18),
              axis.title.y = element_text(size = 18), 
              axis.text.x = element_text(size = 15), 
              axis.text.y = element_text(size = 15)) )
  }
#################
```





# 2. Detailed curation results provide a unique resource in itself

## for algorithm developers 

  * we ourselves benefit from this (will show examples)

```{r t1qcvsgrader,echo=FALSE,eval=FALSE}
temp=qclist[["T1w"]]
temp2=ppmi500
temp2=merge(temp2,temp,by='imageID')
for ( qccol in c("qcfail_background_noise",'qcfail_motion','qcfail_other')) {
  temp2[ is.na(temp2[,qccol]),qccol]='False'
}
mdl = lm( T1Hier_resnetGrade ~ qcfail_background_noise + qcfail_motion + qcfail_other, data=temp2)

failIDsHuman=substr( gsub( 'PPMI', '', temp2$u_hier_id[ temp2$qchuman_T1w!='True' ] ), 0, 6 )

failIDsAuto=substr( gsub( 'PPMI', '', temp2$u_hier_id[ temp2$T1Hier_resnetGrade < 1.02 ] ), 0, 6 )

# table( temp2$T1Hier_resnetGrade >= 1.02, temp2$qchuman_T1w )

```

## for scientists 

  * to have confidence (or at least context regarding quality) in looking at automated IDPs derived from these data

# 3. Processing improves quality/usability further 

## effect of processing by modality 

* for each, summarize how processing improves the data

  * rsfMRI is "easy" to see - throw away motion corrupted data

  * developed methodology specific for PPMI that was informed by this process 

  * automated QC for these modalities for future work

## we provide scientists handles on this so that can be "strict" or "loose" in data selection


* we document these parameters 

# 4. Enables investigation of the "meaning" of M3RI at the individual level 


```{r gpivol,echo=FALSE,eval=FALSE}
ppmi500=antspymm_predictors(ppmi500,TRUE)
zz=ppmi500[ subtyper::fs(ppmi500$DXSubAsyn=='PDSporadicNegative'), ]
xx=ppmi500[ subtyper::fs(ppmi500$DXSubAsyn=='PDSporadicPositive') , ]
voi='T1Hier_vol_bn_str_pu_Asymcit168'
vois=c('T1Hier_vol_bn_gp_gpe_LRAVGcit168',
  'T1Hier_vol_bn_gp_gpi_LRAVGcit168',
  'T1Hier_vol_bn_gp_gpi_Asymcit168',
  'T1Hier_vol_bn_gp_gpe_Asymcit168',
  'T1Hier_vol_bn_str_pu_LRAVGcit168')
close_dfs = find_closest_subjects( zz, xx, k=10, 'commonSex', 'commonAge' )
# vois=c("T1Hier_vol_bn_gp_gpe_LRAVGdeep_cit168")
for ( voi in vois ) {
  cat("\n***************************************\n\n")
  for ( zzminind in 1:nrow(zz)) {
    reftemp = zz[zzminind,c('commonSex','commonAge','brainVolume')]
    refvolneg=zz[zzminind,voi]
    refvolnegbv=zz[zzminind,'brainVolume']
    temp=close_dfs[[zzminind]]
    mydiff = temp[,voi]/temp$brainVolume - refvolneg/refvolnegbv
    mydiff = temp[,voi] - refvolneg
    mytt = t.test( mydiff )
    reftemp$voi = voi
    reftemp$tval=zz[zzminind,'tval']=mytt$statistic
    reftemp$pval=zz[zzminind,'pval']=mytt$p.value
    print( reftemp )
    hist( mydiff, main=voi )
    Sys.sleep(0.5)
  }
  print(voi)
  print(table( zz$tval > 2 ) )
}
summary(lm(  tval ~  commonSex + T1Hier_resnetGrade , data=zz ))


xxid=xx$u_hier_id[1]
mycols = c("commonAge",'commonSex','T1Hier_resnetGrade.SR','AsynStatus',voi,'brainVolume')
posvsneg=rbind( 
  zz[,mycols],
  xx[,mycols]
)
posvsneg$normed = posvsneg[,voi]/posvsneg$brainVolume
temp=ppmi500[subtyper::fs(ppmi500$joinedDX=='PDSporadic'),]
voi='T1Hier_vol_bn_gp_gpi_LRAVGcit168'
voi='T1Hier_vol_bn_gp_gpi_LRAVGcit168'
voisX=c(
  getNamesFromDataframe( c("T1Hier","_pu","vol",'Asym'),temp),
  getNamesFromDataframe( c("T1Hier","_gp","vol",'Asym'),temp), 
  getNamesFromDataframe( c("T1Hier","_pu","vol",'LRAV'),temp),
  getNamesFromDataframe( c("T1Hier","_gp","vol",'LRAV'),temp) )

voisC=c(
  getNamesFromDataframe( c("T1Hier","temporal","thk",'Asym'),temp),
  getNamesFromDataframe( c("T1Hier","temporal","thk",'LRAV'),temp))

vvv=getNamesFromDataframe( c("T1Hier","nbm","thk",'LR'),temp)
vvv=rowMeans(temp[,vvv],na.rm=T)
########################################################
temp$temp = ((temp[,vois])/mean(temp[,vois]))# *(vvv/mean(vvv))
vois='temp'
vois='T1Hier_vol_bn_gp_gpe_LRAVGdeep_cit168'
temp=ppmi500
for ( voi in vois ) {
  mdl=lm( paste(voi, "~ DXSubAsyn + commonSex + commonAge "),data=temp)
#  mdl=lm( paste(voi, "~ AsynStatus + commonSex + commonAge + brainVolume"),data=temp)
  print(summary(mdl))
  print(voi)
  visreg::visreg(mdl,'DXSubAsyn',main=voi)
}
########################################################
```


# 5. Empowers investigation of the "meaning" of M3RI at the population level 





## simlr

```{r simlr,echo=FALSE,eval=TRUE,fig.width=9,fig.height=3,cache=TRUE}
######
ppmi500$allpass=subtyper::fs(
  ppmi500$qchuman_T1w==0 & ppmi500$qchuman_DTI ==0 & ppmi500$qchuman_rsfMRI==0)
dosimlrMH = function( blaster,  energy='reg', nsimlr=5, myseed=3, connect_cog=TRUE, doAsym=TRUE, returnidps=FALSE, restrictDFN=FALSE, doperm=FALSE ) {
  idps=antspymm_predictors(blaster,TRUE,TRUE)
  idps=idps[ -multigrep(antspymm_nuisance_names()[-3],idps)]
  if ( ! doAsym ) {
    idps=idps[ -grep("Asym",idps)]
    } else {
    idps=idps[ -grep("Asymcit168",idps)]
  }
  idps=idps[ -grep("cleanup",idps)]
  idps=idps[ -grep("snseg",idps)]
  idps=idps[ -grep("_deep_",idps)]
  idps=idps[ -grep("fcnxpro134",idps)]
  idps=idps[ -grep("fcnxpro129",idps)]
  idps=idps[ -grep("peraf",idps)]
  idps=idps[ -grep("alff",idps)]
  idps=idps[ -grep("LRAVGcit168",idps)]
  idps=idps[ -grep("_l_",idps,fixed=TRUE)]
  idps=idps[ -grep("_r_",idps,fixed=TRUE)]
  rsfnames = idps[ grep("_2_",idps)]
  if ( restrictDFN ) {
    rsfnames = rsfnames[ grep("Default",rsfnames)]
  } else {
#    rsfnames = rsfnames[ multigrep( c("imbic","TempPar"),rsfnames)]
  }
  t1names = idps[ multigrep( c("T1Hier"),idps,intersect=TRUE)]
  dtnames = unique( c( 
    idps[ multigrep( c("mean_fa","DTI"),idps,intersect=TRUE)],
    idps[ multigrep( c("mean_md","DTI"),idps,intersect=TRUE)] ))
  idps=unique(c(t1names,dtnames,rsfnames))
  if ( returnidps ) return(idps)
  cogs=getNamesFromDataframe( 'updrs', blaster, exclusions=c('4','BL','delta'))
  blaster2=blaster[  blaster$T1Hier_resnetGrade >= 1.02, ]
#    blaster$allpass , ]
  agedf=data.frame(stats::poly(blaster2$age_BL,2))
  names(agedf)=c("age1","age2")
  blaster2=cbind(blaster2,agedf)
  #################################################
  nperms=0
  allnna = blaster2$haveall#  & blaster2$allpass# & subtyper::fs(blaster2$joinedDX == 'CN')
  matsFull = list( 
      t1=blaster2[,t1names], 
      rs=blaster2[,rsfnames],
      dt=blaster2[,dtnames],
      cg=blaster2[,cogs])
  mats = list( 
      t1=antsrimpute(blaster2[allnna,t1names]),
      rs=antsrimpute(blaster2[allnna,rsfnames]),
      dt=antsrimpute(blaster2[allnna,dtnames]),
      cg=antsrimpute(blaster2[allnna,cogs]))
  if ( doperm ) {
    nada=setSeedBasedOnTime()
#    print( paste("perm",nada))
    sss=sample( 1:nrow( matsFull[[1]]  ))
    for ( jj in 1:length( mats ) ) {
        ss=sample( 1:nrow( mats[[jj]]  ))
#        print(head(ss))
        mats[[jj]]=mats[[jj]][sample( 1:nrow( mats[[jj]]  )),]
#        matsFull[[jj]]=matsFull[[jj]][sss,]
    }
  }
  if ( ! connect_cog ) {
    mats=mats[1:(length(mats)-1)]
    matsFull=matsFull[1:(length(matsFull)-1)]
  }
  nms = names(mats)
  regs0 = list()
  for ( x in 1:length(mats)) {
      mats[[x]]=residuals( lm( data.matrix(mats[[x]]) ~ commonSex, data=blaster2[allnna,]))
      mats[[x]]=data.matrix(mats[[x]])
      mycor = cor( mats[[x]] )
      mycor[mycor < 0.8]=0
      regs0[[x]]=data.matrix(mycor)
      }
  names(regs0)=names(mats)
  regs = regularizeSimlr( mats, fraction=0.05, sigma=rep(2.0,length(mats)) )
  names(regs0)=names(mats)
  names(regs)=names(mats)
  if ( connect_cog ) 
    regs[["cg"]] = Matrix(regs0[["cg"]], sparse = TRUE) 
  if ( !doperm )
    for ( pp in 1:length(regs)) plot(image(regs[[pp]]))
  for ( k in 1:length(mats)) {
    if ( ncol(mats[[k]]) != ncol(regs[[k]]) ) {
      regs[[k]]=Matrix(regs0[[k]], sparse = TRUE) 
      msg=paste("regularization cols not equal",k,ncol(mats[[k]]),ncol(regs[[k]]),names(mats)[k])
      message(msg)
      # stop( )
      }
    }
  ########### zzz ############
  myjr = T
  prescaling = c( 'center', 'np' )
  optimus = 'lineSearch'
  maxits = 100
  ebber = 0.99
  pizzer = rep( "positive", length(mats) )
  # if ( connect_cog )  pizzer[length(pizzer)]='either'
  objectiver='cca';mixer = 'pca'
  if ( energy == 'reg') {
    objectiver='regression';mixer = 'ica'
  }
  if ( energy == 'lrr') {
    objectiver='lowRankRegression';mixer = 'pca'
  }
  sparval = rep( 0.8, length( mats ))
  library(FactoMineR)
  library(factoextra)
  if ( connect_cog ){
    res.pca <- PCA(cbind(mats[[1]],mats[[2]],mats[[3]],mats[[4]]),  graph = FALSE)
  } else res.pca <- PCA(cbind(mats[[1]],mats[[2]],mats[[3]]),  graph = FALSE)
  fviz_screeplot(res.pca, addlabels = TRUE, ylim = c(0, 14), ncp=20 ) # beyond 20 <1%
  if ( nsimlr < 1 ) {
    ctit=0
    for ( jj in 1:length(mats) ) {
      ctit=ctit+ncol(mats[[jj]])
      sparval[jj] = 1.0 - 20/ncol(mats[[jj]])
    }
    nsimlr = round( ctit * nsimlr )
    message(paste("nsimlr",nsimlr))
    print(paste("nsimlr",nsimlr))
    print(sparval)
  }
  initu = initializeSimlr(
      mats,
      nsimlr,
      jointReduction = myjr,
      zeroUpper = FALSE,
      uAlgorithm = "pca",
      addNoise = 0 )
  if ( connect_cog ) {
    clist = list()
    inflammNums=which(names(mats)=='cg')
    for ( j in 1:length( mats ) ) clist[[j]] = inflammNums
    for ( j in inflammNums )
      clist[[j]] = (1:length(mats))[ -inflammNums ]
    } else clist=NULL
  simlrX = simlr( mats, regs, iterations=maxits, 
    verbose= !doperm,
    randomSeed = myseed,
    mixAlg=mixer,
    energyType=objectiver,
    scale = prescaling,
    sparsenessQuantiles=sparval,
    expBeta = ebber,
    positivities = pizzer, 
    connectors=clist,
    optimizationStyle=optimus,
    initialUMatrix=initu )

  for ( kk in 1:length(mats) ) {
#    temp = simlrX$v[[kk]]
#    for ( n in 1:ncol(temp)) temp[,n]=abs(temp[,n])/max(abs(temp[,n]))
#    simlrX$v[[kk]]=eliminateNonUniqueColumns(temp)
  }

  #################
  nsimx=nsimlr
  nms = names( simlrX$v ) = names(mats)
  simmat = data.matrix(matsFull[[1]] )%*% abs( simlrX$v[[1]] )
  colnames( simmat ) = paste0(nms[1],colnames( simmat ))
  for ( j in 2:length(mats)) {
      if (names(mats)[j]=='cg' & pizzer[j] != 'positive' ) {
        temp = data.matrix(matsFull[[j]] ) %*% ( simlrX$v[[j]])
      } else temp = data.matrix(matsFull[[j]] ) %*% abs( simlrX$v[[j]] )
      colnames( temp ) = paste0(nms[j],colnames( temp ))
      simmat = cbind( simmat, temp )
  }
  blaster2sim = cbind( blaster2, simmat )
  nsim = ncol( simlrX$v[[1]] )
  simnames = colnames(simmat)
  kk=1
  nmats=1:length(matsFull)
  matsB=mats
  for ( kk in 1:length(mats)) matsB[[kk]]=data.matrix(matsB[[kk]])
  kk=length(mats)
  temp = predictSimlr( matsB, simlrX, targetMatrix=kk, 
        sourceMatrices=nmats[nmats!=kk] )

  return( list( demog=blaster2sim, mats=matsFull, simnames=simnames, simlrX=simlrX, energy=energy, temp=temp ) )
  ################
  }
######################################################################
cogs=getNamesFromDataframe( 'updrs', ppmi500, exclusions=c('4','BL','delta'))
nsm=length(cogs)
nsm=2
permdf=data.frame()
maxperm=200
for ( permxpt in 0:maxperm ) {
  if ( permxpt == 0 ) {
    doperm=FALSE
    permstate='original'
  } else {
    doperm=TRUE
    permstate=paste('perm')
  }
  meeko = dosimlrMH( ppmi500, nsimlr=nsm, energy='cca', connect_cog=T, doAsym=T, 
    restrictDFN=F, doperm=doperm )
  for ( kk in 1:length( (meeko$temp$varxfull )) ) print( max(meeko$temp$varxfull[[kk]]) )
  ######################################################################
  grepper=grep("cg",meeko$simnames)
  if ( length(grepper) > 0 ) {
    simsub=meeko$simnames[ -grepper ]
  } else {
    simsub=meeko$simnames
  }
  # simsub=simsub[ grep("PC1",simsub)]
  dxv='DXSubAsyn'
  dxv='joinedDX'
  for ( nums in 1:1 ) {
    simsub=c(
      paste0("t1PC",nums),
      paste0("rsPC",nums),
      paste0("dtPC",nums) )
    bform=paste("updrs_totscore ~ age_BL + hy_BL+ commonSex+DXSubAsyn")
    bform=paste(cogs[5]," ~ age_BL + commonSex + hy_BL + ",dxv)
    mform1=paste(bform,"+(",paste(simsub,collapse='+'),")")
  # mform2=paste(bform,"*(",paste(simsub,collapse='+'),")")
    temp=meeko$demog[ meeko$demog$allpass, ]  # [ meeko$demog$joinedDX=='PDSporadic', ]
    for ( zz in 1:length(simsub))
      temp[,simsub[zz]]=psych::winsor( temp[,simsub[zz]], 0.01)
    mdl2=lm( mform2 , data=temp )
    mdl1=lm( mform1 , data=temp )
    # mdl=lm( mform , data=meeko$demog )
    bmdl=lm( bform , data=temp[names(predict(mdl2)),] )
    myanv0=anova(bmdl,mdl1)
#    myanv1=anova(bmdl,mdl2)
#    myanv2=anova(mdl1,mdl2)
    summary(mdl2)
    print( paste( nums, myanv0$Pr[2] ) )
    myco=coefficients(summary(mdl1))
    gg1=visreg::visreg( mdl1, simsub[1], gg=TRUE ) + theme_minimal() + ggtitle(paste('T1', permstate,insight::format_p(myco['t1PC1','Pr(>|t|)'])))
    gg2=visreg::visreg( mdl1, simsub[2] , main=paste('rsfMRI', permstate,insight::format_p(myco['rsPC1','Pr(>|t|)'])), gg=TRUE  ) + theme_minimal() + ggtitle(paste('rsfMRI', permstate,insight::format_p(myco['rsPC1','Pr(>|t|)'])))
    gg3=visreg::visreg( mdl1, simsub[3], main=paste('DTI', permstate,insight::format_p(myco['dtPC1','Pr(>|t|)'])), gg=TRUE  ) + theme_minimal() + ggtitle(paste('DTI', permstate,insight::format_p(myco['dtPC1','Pr(>|t|)'])))
    if ( myanv0$Pr[2] < 0.001 )
      grid.arrange(grobs=list(gg1,gg2,gg3),nrow=1)
    nn=nrow(permdf)+1
    permdf[nn,'permstate']=permstate
    permdf[nn,'anv']=myanv0$Pr[2]
    permdf[nn,'pvalt1']=myco['t1PC1','Pr(>|t|)']
    permdf[nn,'pvalrs']=myco['rsPC1','Pr(>|t|)']
    permdf[nn,'pvaldt']=myco['dtPC1','Pr(>|t|)']
    }
}
#################
```


```{r,echo=FALSE,eval=TRUE,message=FALSE,include=FALSE,cache=TRUE,fig.width=5,fig.height=5}
meeko = dosimlrMH( ppmi500, nsimlr=nsm, energy='cca', connect_cog=T, doAsym=T, 
    restrictDFN=F, doperm=FALSE )

bform=paste(cogs[5]," ~ age_BL + commonSex + hy_BL + ",dxv)
bform=paste(cogs[5]," ~ age_BL + commonSex + hy_BL + LEDD +")
bform=paste(cogs[5]," ~ age_BL + commonSex +  hy_BL ")
mform1=paste(bform,"+(",paste(simsub,collapse='+'),")")
temp=meeko$demog[ meeko$demog$allpass & meeko$demog$joinedDX=='PDSporadic', ]
temp=meeko$demog[ meeko$demog$allpass & meeko$demog$DXSubAsyn=='PDSporadicPositive', ]
for ( zz in 1:length(simsub))
  temp[,simsub[zz]]=psych::winsor( temp[,simsub[zz]], 0.01)
mdl1=lm( mform1 , data=temp )
summary(mdl1)

temp=meeko$demog[ meeko$demog$allpass & meeko$demog$DXSubAsyn=='PDSporadicPositive', ]
for ( zz in 1:length(simsub))
  temp[,simsub[zz]]=psych::winsor( temp[,simsub[zz]], 0.01)
mdl1=lm( mform1 , data=temp )
summary(mdl1)

myco=coefficients(summary(mdl1))
gg0=visreg::visreg( mdl1, 'hy_BL', gg=TRUE ) + theme_minimal() + ggtitle(paste('HY',insight::format_p(myco['hy_BL','Pr(>|t|)'])))
gg1=visreg::visreg( mdl1, simsub[1], gg=TRUE ) + theme_minimal() + ggtitle(paste('T1',insight::format_p(myco['t1PC1','Pr(>|t|)'])))
gg2=visreg::visreg( mdl1, simsub[2] , main=paste('rsfMRI', permstate,insight::format_p(myco['rsPC1','Pr(>|t|)'])), gg=TRUE  ) + theme_minimal() + ggtitle(paste('rsfMRI',insight::format_p(myco['rsPC1','Pr(>|t|)'])))
gg3=visreg::visreg( mdl1, simsub[3], main=paste('DTI', permstate,insight::format_p(myco['dtPC1','Pr(>|t|)'])), gg=TRUE  ) + theme_minimal() + ggtitle(paste('DTI',insight::format_p(myco['dtPC1','Pr(>|t|)'])))

temp=meeko$demog[ meeko$demog$allpass & meeko$demog$DXSubAsyn=='PDSporadicNegative', ]
for ( zz in 1:length(simsub))
  temp[,simsub[zz]]=psych::winsor( temp[,simsub[zz]], 0.01)
mdl1=lm( mform1 , data=temp )
summary(mdl1)
```


```{r pupdrs,echo=FALSE,eval=TRUE,message=FALSE,include=TRUE,cache=FALSE,fig.width=5,fig.height=5}
grid.arrange(grobs=list(gg0,gg1,gg2,gg3),nrow=2,
  top=paste("SpPD+ UPDRS Tot from M3RI: R^2",insight::format_value(rsq(mdl1))))
```

```{r interpsimg,echo=FALSE,eval=TRUE,message=FALSE,include=TRUE,cache=FALSE,fig.width=7,fig.height=7}

# myinterp=0
n2show=6
t1int=interpret_simlr_vector( meeko$simlrX, meeko$mats, 't1PC1', n2show=n2show )
rsint=interpret_simlr_vector( meeko$simlrX, meeko$mats, 'rsPC1', n2show=n2show  )
dtint=interpret_simlr_vector( meeko$simlrX, meeko$mats, 'dtPC1', n2show=n2show  )
myggdf = data.frame( 
  idp=names(c(t1int,rsint,dtint)),
  modality=c(rep("t1",n2show),rep("rs",n2show),rep('dt',n2show)),
  value=as.numeric(c(t1int,rsint,dtint)))
myggdf$modality=factor(myggdf$modality)
myggdf$idp=factor(myggdf$idp)
myggdf$value=as.numeric(myggdf$value)
ggbarplot( myggdf, 'idp', 'value', fill='modality',  orientation = "horiz", sort.val ='asc', palette='jco' )
# ggbarplot( myggdf, 'value', 'idp', fill='modality', order='d',  orientation = "horiz")
```


```{r,results='asis',echo=FALSE}

# temp=ztable(mytable(NM.QC.cat~.,data=plot_data),zebra=2)
# Print the ztable object, ensuring it's treated as LaTeX code
# print(temp, type = "html",size=5,caption='NM QC',sidewaystable=TRUE)

permdf %>% 
   knitr::kable("html", booktabs = TRUE, caption=paste('SiMLR permutation summary')) %>%
      kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```

```{r,echo=FALSE,fig.width=8,fig.height=4}
permdf$logp = -1.0 * log10( permdf$anv )
gghistogram( permdf, x = 'logp',
      add = "mean", add_density = FALSE, title='SiMLR original data projection vs permuted projections: model significance', fill='permstate', legend='top', 
      xlab='-log_10(p) updrs total score from t1, rsfmri + dti', palette='jco')
```